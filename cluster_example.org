#+begin_src ruby
kmers_json = <<JSON
{"GTGTACATGTCGATGC": [113, 1]
, "GTGTACATGTCGATGT": [23, 0.896561]
, "GTGTACATGCGATGCT": [7, 0.798848]
, "CTTGTACATGTCGATGC": [6, 0.259889]
, "GTGTACATGTCATGCT": [6, 0.306842]
, "GTGTACATGTCGTGCT": [6, 0.329062]
, "GTGTACATGTCGATTGC": [4, 0.117831]
, "GTGTACATGTCTGCTC": [4, 0.279586]
, "GTGTACATGTGGATGCT": [4, 0.0924509]
, "GTGTACATGTCGAGCT": [3, 0.142532]
, "GTGTACATGTCGAATGC": [3, 0.122288]
, "GTGTACATGTCCGATGC": [3, 0.414234]
, "GTGTACATGTCGTGTC": [3, 0.102646]
, "GTGTACATGTCGATGA": [2, 0.030334]
, "GTGTACATGCGATGCA": [2, 0.282863]
, "GAGTACACTGTCGCTG": [2, 0.0354077]
, "GTGTATACATGTCGTG": [1, 0.367132]
, "GTGTACATGTCGATTCT": [1, 0.0103594]
, "GTGTACATGTCATGTA": [1, 0.0310968]
, "GTGTACAATGTCGTGCT": [1, 0.0278993]
, "GTGTACATGTCGAGGTG": [1, 0.0752032]
, "GTGTACATGTCAATGTC": [1, 0.103659]
, "GTGTACATGTCGAATGT": [1, 0.0223707]
, "GTGTACATGTCGGATGCC": [1, 0.0332159]
, "GTGTACATGTCGTGCA": [1, 0.037486]
, "GTGTACATGTCGGATGC": [1, 0.037077]
, "GTGTACATGTCGAGCCG": [1, 0.0755326]
, "GTGTACATGCGCTGTC": [1, 0.0361614]
, "GTGTATACATGTCATG": [1, 0.0148547]
, "GTGTTACATGTGGATGCT": [1, 0.00503255]
, "GTGTACATGTCATGCGG": [1, 0.0514894]
, "GAGTACACACCACTCTG": [1, 0.0561335]
, "GAGTATACATGTCGTG": [1, 0.0240265]
, "CAGTACACTGTCGCTG": [1, 0.0119634]
, "GTGTACATGCGATGCCT": [1, 0.0828592]
, "GTGTACATGTCGACTA": [1, 0.0108699]
, "GTGTACATGCGATGTG": [1, 0.322702]
, "GTTGTTACATGTCGATGC": [1, 0.0186362]
, "GTGTACATGTCTGCTA": [1, 0.0236677]
, "GTGTACATGTCGACAGG": [1, 0.00342138]
, "GTGTACATGTCATGCCT": [1, 0.0879174]
, "CAGTACACTGTCGCTA": [1, 0.0846089]
, "GTGTACATGTCGAGTA": [1, 0.0087958]
, "CAGTACACTGTAGCTA": [1, 0.0279201]
, "GTGTACACTGTCGCTA": [1, 0.251023]
, "ATGTACGCTGTAGCTGG": [1, 0.00653765]
, "GTGTTACATGTCGATGC": [1, 0.00782994]
, "ATGTACGCTGTAGCTG": [1, 0.00743107]
, "ATGTACGCTGTCGCTA": [1, 0.027018]
, "GTGTACACTGTCCGCTA": [1, 0.128547]
}
JSON
      
    require 'json'
    kmers = JSON.parse(kmers_json).sort_by{|k, v| v.map{|x| -x}}
    
    white_pc = 80
  
    latex_rows = kmers.map{ |kmer, data|
      n, prob = data
      green_pc = ((n.to_f / kmers.first.last.first) * 100).round
      count_color = "green!#{green_pc}!red!#{100 - white_pc}!white"
      count_cell = "\\cellcolor{#{count_color}} #{n}"
      green_pc = (prob * 100).round
      prob_color = "green!#{green_pc}!red!#{100 - white_pc}!white"
      prob_cell = "\\cellcolor{#{prob_color}} #{"%.2f" % prob}"
        "    #{kmer} & #{count_cell} & #{prob_cell} \\\\"
    }.join("\n")
  
    table_header = "    \\textbf{homopolymer-space 16-mer} & \\textbf{n} & " + 
                   "\\textbf{qual.} \\\\ \\hline \n"
    latex_table = "\\begin{tabular}{|l|r|r|}\n#{table_header}#{latex_rows}\n\\hline\\end{tabular}"
  
  
    def connected(k1, k2)
      def connected_helper(s1, s2)
        s1.zip(s2).each_with_index do |bases, i|
          b1, b2 = bases
          next if b1 == b2
          return true if s1[i + 1 .. -1] == s2[i + 1 .. -1]
          return true if s1[i .. -1] == s2[i + 1 .. -1]
          return true if s1[i + 1 .. -1] == s2[i .. -1]
          return false
        end
        false
      end
      k1 = k1.chars.to_a; k2 = k2.chars.to_a
      connected_helper(k1, k2) or connected_helper(k1.reverse, k2.reverse)
    end
  

used = kmers.product(kmers).select{|k1, k2| connected(k1.first, k2.first)}
                    .map{|k1, k2| [k1.first, k2.first]}.flatten.uniq
unused = kmers.map(&:first) - used
#+end_src

#+results:

